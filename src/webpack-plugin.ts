import crypto from 'crypto';
import path from 'path';
import { Compilation, Compiler } from 'webpack';

import { buildQueryMap, createQueryCollection, extractQueries } from './core';
import HasuraApi from './hasura';

export interface GraphQLPluginListener {
    _notify(value: any): void;
}
export type HashQueryFn = (query: string) => string;

const defaultHashQuery: HashQueryFn = (query) => {
    return crypto.createHash('sha256').update(query).digest('hex');
};

const NAME = 'HasuraAllowListPlugin';

export interface HasuraAllowListPluginOptions {
    hasura: {
        host: string;
        secret: string;
    };
    collectionName: string;
    moduleName?: string;
    provider?: any;
    addTypename?: boolean;
    hashQuery?: HashQueryFn;
    excludeRegex?: RegExp;
    graphqlRegex?: RegExp;
    jsRegex?: RegExp;
}

class HasuraAllowListWebpackPlugin {
    /**
     * @type HasuraAllowListPluginOptions
     */
    options: Required<HasuraAllowListPluginOptions>;

    /**
     * @type String
     */
    moduleName;

    private listeners: GraphQLPluginListener[] = [];

    private hasura: HasuraApi;

    /**
     *
     * @param options {HasuraAllowListPluginOptions}
     */
    constructor(options: HasuraAllowListPluginOptions) {
        this.options = (options || {}) as any;
        this.hasura = new HasuraApi(this.options.hasura);

        if (this.options.provider) {
            this.options.provider.addListener(this);
        } else {
            this.listeners = [];
        }
        this.moduleName = this.options.moduleName || path.resolve('node_modules/hasura-allow-list.json');
        this.options.addTypename = typeof this.options.addTypename !== 'undefined' ? this.options.addTypename : true;
        this.options.hashQuery =
            typeof this.options.hashQuery !== 'undefined' ? this.options.hashQuery : defaultHashQuery;
        this.options.excludeRegex = this.options.excludeRegex || /[\\/]node_modules[\\/]/;
        this.options.graphqlRegex = this.options.graphqlRegex || /(.graphql|.gql)$/;
        this.options.jsRegex = this.options.jsRegex || /(.jsx?|.tsx?)$/;
    }

    apply(compiler: Compiler) {
        const { jsRegex, addTypename, collectionName } = this.options;
        let queryMap: Record<string, string> = {};

        compiler.hooks.thisCompilation.tap(NAME, (compilation, { normalModuleFactory }) => {
            const logger = compilation.getLogger(NAME);

            compilation.hooks.processAssets.tap(
                {
                    name: NAME,
                    stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,
                },
                (assets) => {
                    logger.debug('CompilationAssets hook');

                    const found = Object.entries(assets)
                        .filter(([pathname]) => jsRegex.test(pathname))
                        .flatMap(([pathname, source]) => {
                            return extractQueries(source.source().toString('utf-8'), addTypename);
                        });

                    logger.info('Found %n queries', found.length);
                    if (found.length) {
                        queryMap = { ...queryMap, ...buildQueryMap(found, addTypename) };
                    }
                },
            );
        });

        compiler.hooks.done.tapAsync(NAME, async (_, callback) => {
            if (!Object.keys(queryMap).length) {
                callback();
                return;
            }
            const logger = compiler.getInfrastructureLogger(NAME);

            await createQueryCollection({
                hasura: this.hasura,
                name: collectionName,
                logger,
                queryMap,
            });

            callback();
        });
    }
    /*
    _onAssets(assets: Record<string, Source>) {
        const { excludeRegex, graphqlRegex, jsRegex } = this.options;
        compilation.chunks.forEach((chunk) => {
            chunk.files.forEach((filename) => {
                compilation.logger.info(`Checking file ${filename}`);
                if (excludeRegex.test(filename)) return;
                if (graphqlRegex.test(filename)) {
                } else if (jsRegex.test(filename)) {
                    const source = String(compilation.assets[filename].source());
                    const literalContents = ExtractFromJs.findTaggedTemplateLiteralsInJS(source, 'gql');
                    if (literalContents) {
                        compilation.logger.info(`found gql tag in ${filename}`);
                    }
                }
                // Get the asset source for each file generated by the chunk:
            });
        });
    }      */
}

export default HasuraAllowListWebpackPlugin;
